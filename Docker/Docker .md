---
sticker: emoji//1f433
---
[[The book]]



镜像是如何实现的？镜像是如何被每一个容器所使用的？Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层。每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。

**也就是说，容器实现了和宿主机的进程、网络、文件系统的隔离，**
这就是Docker处处需要mapping


## What is Docker?
- 定义
	- a person moving goods on and off ships = 码头工人。
	- Docker allows you to **package** an application with **all of its dependencies** into a **standardized unit**(i.e. containers) for software development.
	- 主要应用在Linux和后台一些应用的一个虚拟机。

docker ps: process status. Each docker container is actually a process
container: **a running image, a standardized unit, a lightweight, standalone, executable package of software that includes everything needed to run an application**

Docker 镜像其实本质就是一个压缩包，

进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。


## Docker Basics
### Concepts
- Registry 仓库 
- Image 镜像
- Container 容器
- Dockerfile => 配置文件：如何构建一个镜像
- tar 文件 => 镜像保存为tar文件，他人可以通过load指令重新加载成一个镜像

### Dockerfile
Automate the process of assembling an image in Docker.
```shell
FROM # 设置基础镜像，enough to build an image, which is actually a copy of alpine.
WORKDIR # 指定shell命令运行在哪个folder下，没有就自动创建
COPY <source> <destination> # 复制当前host的A目录下文件到镜像的B目录下
RUN # 运行shell命令，构建镜像时执行
CMD # 容器启动时执行的命令，构建镜像完成后执行


COPY v.s. ADD
COPY # 地址是文件系统的root
ADD # ADD自带解压，不仅可以是文件系统的root，也可以是一个URL。如果用到网络资源，可以使用ADD

CMD v.s. ENTRYPOINT # 指定容器启动之后的核心脚本
执行顺序与格式有关，ENTRYPOINT非json则以ENTRYPOINT为准，如果ENTRYPOINT和CMD都是JSON，则ENTRYPOINT+CMD拼接成shell。ENTRYPOINT指定的命令可以在run时追加参数。

——————

EXPOSE # 指定当前image暴露的port
VOLUME /a/b # 指定映射文件. e.g. 把容器中的/a/b文件映射到了host machine的一个目录下。一般是映射到匿名卷

——————参数
ENV # 指定当前容器的环境变量，构建时到运行时一直生效
e.g. ENV A=10
     CMD echo $A
ARG # 参数，构建时有效，但运行时失效。构建时临时修改内部变量

———————
LABEL # 声明一些metadata
ONBUILD ENV C=100 # 其他基于本镜像的镜像执行

———————
STOPSIGNAL # 容器用什么样的信号可以停止
HEALTHCHECK # 检查容器健康状况的配置
SHELL # 指定当前容器运行的shell是哪一种 bin/sh bin/bash

```

## Why Docker? What is Virtualization?

- Virtual Machine 虚拟机 => Virtualization 虚拟化 
	- 虚拟化是一项技术
	- 创建虚拟环境和虚拟机器的技术
	- 在电脑上，通过抽象真实硬件为虚拟硬件，让虚拟硬件和所创建的虚拟环境/机器进行交互
	- think computer as a box, virtualization is the magical dividers to create smaller boxes from the big one => abstract and divide hardware's capabilities among various users and tasks => do lots of different things at the same time => easy, safe, smart
	- Docker是虚拟化技术的产物


## Docker advanced
### Docker Network
How does container communicate with each other?
Docker provides a network that offers connection, DNS resolution, and ?
There are 7 types of network. Why networks have types?
bridge
link

### Docker Storage
Volume
Containers are short-lived, so if we want to persist data. Store it on your host file system, i.e. volume, i.e. a designated directory. Also, this volume can be mapped to your own or other containers.

### Docker Compose
docker compose
- orchestration of containers by docker-compose.yml, which manages:
	- network
	- storage
	- interaction
	- other config

## Summary

Docker 也有自己的问题 => Kubernates


mapping in Docker

The concept of "mapping" in Docker is indeed a fundamental aspect that is pervasive throughout its architecture and usage. Mapping in Docker typically involves connecting various resources and configurations from the host environment to the containers or between containers themselves. Here’s a breakdown of how mapping is used in Docker and why it’s so integral:

### 1. **Filesystem Mapping in Dockerfiles**

In Dockerfiles, the `COPY` and `ADD` commands are used to map (or copy) files and directories from the build context (the local file system where Docker is run) into the filesystem of the Docker image being built. This allows the Docker image to contain all necessary application code and dependencies.

### 2. **Port Mapping in Docker and Docker Compose**

In both Docker run commands and Docker Compose configurations, port mapping is extensively used to connect container ports to host ports. This is crucial for allowing communication from outside the Docker host to services running inside containers.

- **Docker Run**: Using the `-p` flag, for example, `docker run -p 80:80`, maps port 80 of the host to port 80 of the container, allowing external access to the service running on that container port.
- **Docker Compose**: In a `docker-compose.yml` file, you might see ports specified under services which perform a similar mapping, e.g., `ports: - "4000:80"` which maps port 80 inside the container to port 4000 on the host.

### 3. **Volume Mapping (`-v` or `--volume` Flag)**

Volume mapping is used to persist data generated by and used within containers. This is done via the `-v` or `--volume` flag in Docker run commands, or through volume configurations in Docker Compose.

- **Purpose**: Containers are ephemeral and stateless; when they are removed, their filesystem disappears with them. By mapping volumes, data can persist beyond the life of a container, and can also be shared between containers.
- **Example**: `docker run -v /host/data:/container/data` maps a directory from the host (`/host/data`) to a directory in the container (`/container/data`). In Docker Compose, you might define a volume and specify its mount path in services.

### 4. **Inter-container Communication**

In Docker Compose, besides port mapping, networks are also used to map or link containers to each other, enabling them to communicate. This does not necessarily map ports directly but connects containers to a virtual network, allowing them to communicate using service names as hostnames.

### Why is Mapping Pervasive in Docker?

- **Abstraction and Isolation**: Mapping allows Docker to maintain container isolation while still providing containers with limited and controlled access to host resources (like ports and files).
- **Flexibility and Control**: Users have precise control over what parts of the host system a container can access and what parts of a container are exposed to the outside world or to other containers.
- **State Management and Persistence**: By using volume mapping, Docker can support stateful applications like databases or applications that need to maintain state across sessions or deployments.

### Core Understanding of Docker

Understanding mapping in Docker helps clarify Docker's approach to resource management, encapsulation, and isolation, which are central to its utility and effectiveness in software development and deployment. Mapping is essentially about connecting and integrating securely isolated environments (containers) with necessary external resources or other containers in a manageable way.


tumbles
### Summary of Key Points and Solutions

1. **Docker and PostgreSQL Setup**:
    
    - **Initial Connection Issues**: We initially faced issues with the backend connecting to the PostgreSQL database. The solution involved ensuring that the backend container correctly referenced the PostgreSQL service name (`db`) instead of `localhost`.
    - **Correct Database URL**: Configured the `DATABASE_URL` in the backend to use `postgres://username:password@db:5432/tododb`.
2. **Database Initialization Script**:
    
    - **Role and Database Creation**: The `init.sql` script failed because the role `username` already existed, causing the script to stop execution.
    - **Proper Script Placement**: Ensured the `init.sql` file was correctly placed in `./backend/init.sql` and correctly mounted in the Docker container via `docker-compose.yml`.
3. **Reinitialization of the Database**:
    
    - **Clear Volumes for Fresh Start**: Used `docker-compose down -v` to remove existing volumes and ensure the database is reinitialized.
    - **Automated Role and Database Creation**: Modified the `init.sql` to include `DO` blocks for checking and creating roles and databases only if they do not exist.
4. **Logging and Debugging**:
    
    - **Database Logs**: Monitored PostgreSQL logs to debug issues with initialization scripts and ensure that the scripts were executed.
    - **RAISE NOTICE**: Incorporated `RAISE NOTICE` within a `DO` block to provide feedback on the successful creation of the `tasks` table.
5. **Handling Errors and Ensuring Table Creation**:
    
    - **Table Creation Check**: Ensured the `tasks` table was created if it did not exist, using a conditional check within a `DO` block in the `init.sql`.

### Corrected `init.sql` Script

sql

Copy code

`-- Check if role exists, if not create it DO $do$ BEGIN     IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'username') THEN         CREATE ROLE username WITH LOGIN PASSWORD 'password';     END IF; END $do$;  -- Check if database exists, if not create it DO $do$ BEGIN     IF NOT EXISTS (SELECT FROM pg_catalog.pg_database WHERE datname = 'tododb') THEN         CREATE DATABASE tododb OWNER username;     END IF; END $do$;  -- Connect to the tododb database \c tododb  -- Create the tasks table if it does not exist DO $do$ BEGIN     IF NOT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'tasks') THEN         CREATE TABLE tasks (             id SERIAL PRIMARY KEY,             description VARCHAR(255) NOT NULL         );         RAISE NOTICE 'Table "tasks" has been successfully created.';     ELSE         RAISE NOTICE 'Table "tasks" already exists.';     END IF; END $do$;`

### Docker-Compose Configuration

yaml

Copy code

`version: '3.8'  services:   db:     image: postgres:latest     volumes:       - postgres-data:/var/lib/postgresql/data       - ./backend/init.sql:/docker-entrypoint-initdb.d/init.sql     environment:       POSTGRES_DB: tododb       POSTGRES_USER: username       POSTGRES_PASSWORD: password     networks:       - todo-network    backend:     build: ./backend     ports:       - "8080:8080"     environment:       DATABASE_URL: postgres://username:password@db:5432/tododb     depends_on:       - db     networks:       - todo-network  networks:   todo-network:     driver: bridge  volumes:   postgres-data:     driver: local`

### Steps to Run

1. **Remove existing containers and volumes**:
    
    bash
    
    Copy code
    
    `docker-compose down -v`
    
2. **Rebuild and start the containers**:
    
    bash
    
    Copy code
    
    `docker-compose up --build`
    
3. **Check the PostgreSQL container logs**:
    
    bash
    
    Copy code
    
    `docker logs <postgres_container_name_or_id>`
    

This comprehensive approach ensured that the PostgreSQL database was correctly initialized with the required schema and that the backend could successfully connect and interact with the database.