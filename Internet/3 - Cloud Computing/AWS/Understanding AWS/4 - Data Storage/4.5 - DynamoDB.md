## NoSQL databases
- Non-relational databases and distributed, e.g. MongoDB, DynamoDB, ...
- NoSQL databases do not support query joins (or just limited support)
- All the data that is needed for a query is present in one row
- Don’t perform aggregations such as “SUM”, “AVG”, ...
- Scale horizontally
- There’s no “right or wrong” for NoSQL vs SQL, they just model data differently with different user queries.

## DynamoDB: Fully managed NoSQL database
- Fully managed, highly available with **replication** across multiple AZs  
- NoSQL database - not a relational database  
- Scales to massive workloads, distributed database  
- Millions of requests per seconds, trillions of row, 100s of TB of storage
- Fast and consistent in performance (low latency on retrieval)
- Integrated with IAM for security, authorization and administration
- Enables event driven programming with DynamoDB Streams
- Low cost and auto-scaling capabilities
- Standard & Infrequent Access(IA) Table Class

### Basics
- Made of tables
- Primary key(decided at creation time)
	- Option 1: Partition Key(HASH)
		- unique for each item
		- diverse so that the data is distributed
		- No two items can have the same partition key value
	- Option 2: Partition Key + Sort Key(HASH + RANGE)
		- unique for each item
		- grouped by partition key
- Infinite number of items
- Each item has attributes
- The maximum size of an item in a DynamoDB table is **400KB**
- Data types supported:
	- Scalar types - String, Number, Binary, Boolean, Null
	- Document types - List, Map
	- Set types - String Set, Number Set, Binary Set
- Operation
	- Read: GetItem, Scan(-> parallel scan)
	- Write: PutItem, DeleteItem, DeleteTable
	- Batch Operations: BatchWriteItem, BatchGetItem
	- PartiQL: select, insert, update and delete data using SQL
	- Conditional Writes
	
### Manage table capacity
- capacity modes
	- provisioned mode (default): plan capacity beforehand and pay for provisioned r/w
	- on-demand: pay for what you use

- capacity units: Table must have provisioned r/w capacity units
	- RCU: One Read Capacity Unit
		- = 2 Eventually Consistent Read per second: may get stale data due to replication if immediate read just after a write
		- = 1 Strongly Consistent Read per second for an item up to 4KB in size
	- WCU: Write Capacity Units, one write per second for an item up to 1KB in size
	- RCU and WCU are decoupled, so you can increase/decrease each value separately

- Partitions Internal
	- Partition keys go through a hashing algorithm to know which partition they go to

- Throttling
	- If exceed provisioned RCUs/WCUs, we get `ProvisionedThroughputExceededException`
	- Reasons:  
		- Hot Keys – one partition key is being read too many times (e.g., popular item)
		- Hot Partitions
		- Very large items, remember RCU and WCU depends on size of items
	- Solutions:
		- Exponential backoff when exception is encountered (already in SDK)
		- Distribute partition keys as much as possible
		- If RCU issue, we can use DynamoDB Accelerator (DAX)

### Indexes
- Types
	- LSI - Local Secondary Index: 
		- Alternative Sort Key for your table (same Partition Key as that of base table)
		- The Sort Key consists of one scalar attribute (String, Number, or Binary)
		- Up to 5 Local Secondary Indexes per table
		- Must be defined at table creation time
		- Attribute Projections – can contain some or all the attributes of the base table (KEYS_ONLY, INCLUDE, ALL)

	- GSL - Local Secondary Index:
		- 

### Optimistic Locking
- Strategy to ensure an item hasn't changed before update/delete.
- Each item has an attribute that acts as a version number

### DAX: DynamoDB Accelerator
- A fully managed, highly available, seamless in-memory cache for DynamoDB that delivers up to a 10x performance improvement without requiring developers to manage cache invalidation, data population, or cluster management. 
- Solves the hot key problem(too many reads): caches the most frequently used data, thus offloading the heavy reads on hot keys off your DynamoDB table, hence preventing the `ProvisionedThroughputExceededException` exception.

- Enables event driven programming with DynamoDB Streams  
- Standard & Infrequent Access (IA) Table Class

#### DAX v.s. ElastiCache


### DynamoDB Streams
- Ordered stream of item-level modifications (create/update/delete) in a table
- Integrated with Lambda so that you create triggers that auto respond to events in real-time
- Stream records can be:  
	- Sent to Kinesis Data Streams  
	- Read by AWS Lambda  
	- Read by Kinesis Client Library applications
- Data Retention for up to 24 hours
- Use cases:
	- react to changes in real-time (welcome email to users)
	- Analytics
	- Insert into derivative tables
	- Insert into OpenSearch Service
	- Implement cross-region replication: enable DynamoDB to get a changelog and use that changelog to replicate data across replica tables in other AWS Regions.

### TTL

### CLI

### Transactions

### Session State

### Partitioning Strategies

### Conditional Writes, Concurrent Writes & Atomic Writes

### Patterns with S3

### Operations

### Security

It has an out-of-the-box caching feature.